<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Prompts - 2025 Reading Challenge</title>
  <link rel="icon" href="favicon.png" type="image/png">
  <link rel="apple-touch-icon" href="/ios-icon.png">
  <meta name="theme-color" content="#247182" />
  <meta name="apple-mobile-web-app-status-bar-style" content="#247182">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;700;800&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="menu.css">
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: 'Poppins', sans-serif;
      background: #247182;
      color: #333;
    }

    #page-shell {
      background: #f4f4f4;  /* actual visible page background */
      min-height: 100vh;
      padding-top: 1rem;
    }

    .container {
      max-width: 1100px;
      margin: 6rem auto 3rem;
      padding: 0 1rem;
    }

    h1 {
      font-size: 2.5rem;
      color: #247182;
      font-weight: 800;
      text-align: center;
      margin: 0 0 1rem;
    }

    #filterButtons {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 0.5rem;
      margin-bottom: 1.0rem;
    }

    .filter-btn {
      background: white;
      color: #247182;
      border: 2px solid #247182;
      border-radius: 30px;
      padding: 0.5rem 1rem;
      font-family: 'Poppins', sans-serif;
      font-weight: bold;
      cursor: pointer;
      transition: 0.3s ease;
    }

    .filter-btn:hover,
    .filter-btn.active {
      background: #247182;
      color: white;
    }

    input[type="text"] {
      width: 100%;
      max-width: 400px;
      padding: 0.75rem;
      border: 2px solid #247182;
      border-radius: 8px;
      margin: 0 auto 1rem;
      display: block;
      font-size: 1rem;
      font-family: 'Poppins', sans-serif;
    }

    /* Generic bubble style (match rest of site) */
    .bubble {
      background: #fff;
      border-radius: 14px;
      padding: 1.2rem;
      box-shadow: 0 4px 10px rgba(0,0,0,0.06);
      margin-bottom: 1rem;
      transition: transform .2s ease, box-shadow .2s ease;
    }

    .bubble:hover {
      transform: scale(1.02);
      box-shadow: 0 6px 14px rgba(0,0,0,0.08);
    }

    /* Progress bubble sits under filter buttons */
    #progressBubble {
      min-height: 80px;          /* keeps nice chunk of space */
      margin-bottom: 1.5rem;
    }

    #progressBubble h2 {
      font-size: 1.3rem;
      color: #247182;
      margin: 0 0 0.5rem;
    }

    .progress-top-row {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 0.75rem;
      margin-bottom: 0.4rem;
      font-size: 0.95rem;
    }

    .progress-percent {
      font-weight: 700;
      color: #247182;
    }

    .progress-bar-container {
      background: #ddd;
      border-radius: 6px;
      width: 100%;
      height: 18px;
      overflow: hidden;
      margin-top: 0.2rem;
    }

    .progress-bar {
      background: #247182;
      height: 100%;
      width: 0;
    }

    .prompt-grid {
      display: grid;
      gap: 1.5rem;
      grid-template-columns: repeat(1, 1fr);
    }

    @media (min-width: 700px) {
      .prompt-grid {
        grid-template-columns: repeat(3, 1fr);
      }
    }

    /* ðŸŽ¬ Animated prompt cards */
    .prompt-card {
      background: white;
      border-radius: 1rem;
      padding: 1.5rem;
      box-shadow: 0 0 10px rgba(0,0,0,0.1);
      cursor: pointer;

      /* Smooth hover transition */
      transition: transform 0.25s ease, box-shadow 0.25s ease;

      /* Entrance animation */
      opacity: 0;
      transform: translateY(10px);
      animation: promptIn 0.35s ease forwards;
      animation-delay: var(--delay, 0s);
    }

    .prompt-card:hover {
      transform: scale(1.03);
      transition: transform 0.25s ease;
      box-shadow: 0 6px 14px rgba(0,0,0,0.14);
    }

    .prompt-card.grayed-out {
      color: #cccccc;
    }

    .prompt-card h2 {
      font-size: 1rem;
      color: #247182;
      margin: 0 0 0.5rem;
      font-style: normal;
    }

    .prompt-card h3 {
      font-size: 1.25rem;
      font-weight: 800;
      margin: 0 0 0.5rem;
      color: inherit;
    }

    .prompt-card p,
    .prompt-card .creator {
      font-size: 0.9rem;
      margin: 0;
      color: inherit;
    }

    @keyframes promptIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Respect reduced motion preferences */
    @media (prefers-reduced-motion: reduce) {
      .prompt-card {
        animation: none !important;
        opacity: 1;
        transform: none;
      }
      .bubble {
        transition: none !important;
        transform: none !important;
      }
    }

    .footer-logo-container {
      width: 350px;
      height: 140px;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .footer-logo {
      width: 100%;
      height: auto;
    }

    .site-footer {
      margin-top: 3rem;
      padding: 2rem 1rem;
      background-color: transparent;
      display: flex;
      justify-content: center;
    }

    .print-btn {
      background: #ffffff;
      color: #247182;
      border: 2px solid #247182;
      border-radius: 999px;
      padding: 0.35rem 0.9rem;
      font-size: 0.9rem;
      font-weight: 600;
      font-family: 'Poppins', sans-serif;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease, transform 0.2s ease;
    }

    .print-btn:hover {
      background: #247182;
      color: #ffffff;
      transform: scale(1.03);
    }
    /* Hide cards while we wait for submissions if auto-filtering */
.prompt-grid.loading {
  visibility: hidden;
}
  </style>
</head>
<body>
  <div id="page-shell">
    <header id="main-header">
      <div class="site-name">
        <img src="favicon.png" alt="Icon" />
        <span class="desktop-title">2025 Reading Challenge</span>
      </div>
      <nav class="menu"></nav>
      <button class="menu-toggle" id="menu-button">&#9776;</button>
    </header>

    <div class="mobile-menu" id="mobileMenu"></div>

    <div class="container">
      <h1>Prompts</h1>
      <input type="text" id="searchInput" placeholder="Search prompts..." />
      <div id="filterButtons" class="filter-buttons-container"></div>

      <!-- Progress bar area (always shown, content changes) -->
      <div id="progressBubble" class="bubble"></div>

      <div id="promptGrid" class="prompt-grid"></div>
    </div>

    <footer class="site-footer">
      <div class="footer-logo-container">
        <img src="reading-challenge-logo.png" alt="Reading Challenge Logo" class="footer-logo" />
      </div>
    </footer>
  </div>

  <!-- Confetti library -->
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.3/dist/confetti.browser.min.js"></script>
  <script>
// Use prompts that prompts.js already put on window (or fall back to empty)
window.prompts = Array.isArray(window.prompts) ? window.prompts : [];

  const PARTICIPANTS = ["Cassy", "Cindy", "Noah", "Rusty", "Winny", "Zoey"];
  let allSubmissions = [];
  let activeParticipant = null;
  let initialAutoFilterReader = null;   // who we auto-filter for at startup (if any)
  let submissionsLoaded = false;

  // ðŸŽ‰ Confetti helper
  function launchConfetti() {
    if (typeof confetti !== "function") return;

    const duration = 2000; // 2 seconds
    const end = Date.now() + duration;

    (function frame() {
      confetti({
        particleCount: 10,
        angle: 60,
        spread: 100,
        origin: { x: 0, y: 0.8 }
      });
      confetti({
        particleCount: 10,
        angle: 120,
        spread: 100,
        origin: { x: 1, y: 0.8 }
      });

      if (Date.now() < end) {
        requestAnimationFrame(frame);
      }
    })();
  }

  function getTotalPrompts() {
    return Array.isArray(window.prompts) ? window.prompts.length : 85;
  }

  function getCompletedCountFor(reader) {
    if (!reader || !allSubmissions.length) return 0;
    const completedSet = new Set(
      allSubmissions
        .filter(s => s.Reader === reader)
        .map(s => s.Prompt)
    );
    return completedSet.size;
  }

  // Renders participant filter buttons (no Clear Filter button)
  function renderFilterButtons() {
    const container = document.getElementById("filterButtons");
    container.innerHTML = "";

    PARTICIPANTS.forEach(name => {
      const btn = document.createElement("button");
      btn.className = "filter-btn";
      btn.textContent = name;

      btn.onclick = () => {
        const wasActive = activeParticipant === name;
        const willBeActive = !wasActive;

        // Toggle active participant
        activeParticipant = willBeActive ? name : null;

        // Re-render UI
        renderFilterButtons();
        renderPrompts(window.prompts);
        updateProgressUI();

        // ðŸŽ‰ Confetti when this person has completed all prompts
        if (willBeActive && submissionsLoaded) {
          const totalPrompts = getTotalPrompts();
          const completed = getCompletedCountFor(name);
          if (completed >= totalPrompts) {
            launchConfetti();
          }
        }
      };

      if (activeParticipant === name) {
        btn.classList.add("active");
      }

      container.appendChild(btn);
    });
  }

  // Apply or remove gray-out based on allSubmissions + activeParticipant
 function updateGrayOut() {
  const cards = document.querySelectorAll(".prompt-card");

  cards.forEach(card => {
    const num = card.dataset.promptNumber; // string from data-attribute

    const isComplete =
      activeParticipant &&
      allSubmissions.some(
        s => s.Reader === activeParticipant && s.Prompt === num
      );

    card.classList.toggle("grayed-out", !!isComplete);
  });
}

  // âœ… Update progress bubble contents
  function updateProgressUI() {
    const bubble = document.getElementById("progressBubble");
    if (!bubble) return;

    const totalPrompts = getTotalPrompts();

    // No reader selected â†’ show helper text
    if (!activeParticipant) {
      bubble.style.visibility = "visible";
      bubble.innerHTML = `
        <h2>Prompt Progress</h2>
        <p style="margin:0; font-size:0.95rem;">
          Select a reader above to highlight which prompts they've completed and see their overall progress.
        </p>
      `;
      return;
    }

    // If submissions not loaded yet, show loading text
    if (!allSubmissions.length) {
      bubble.style.visibility = "visible";
      bubble.innerHTML = `
        <h2>${activeParticipant}'s Progress</h2>
        <div class="progress-top-row">
          <span>Loading progressâ€¦</span>
        </div>
      `;
      return;
    }

    const completedCount = getCompletedCountFor(activeParticipant);
    const pct = totalPrompts
      ? Math.round((completedCount / totalPrompts) * 100)
      : 0;

    bubble.style.visibility = "visible";
    bubble.innerHTML = `
      <h2>${activeParticipant}'s Progress</h2>
      <div class="progress-top-row">
        <span>${completedCount} of ${totalPrompts} prompts completed</span>
        <span class="progress-percent">${pct}%</span>
      </div>
      <div class="progress-bar-container">
        <div class="progress-bar" style="width:${pct}%;"></div>
      </div>
    `;
  }

  function renderPrompts(prompts) {
    const grid = document.getElementById("promptGrid");
    const input = document.getElementById("searchInput");
    const search = input.value.toLowerCase();

    grid.innerHTML = "";
    const filteredPrompts = prompts.filter(p =>
      p.title.toLowerCase().includes(search) ||
      (p.description && p.description.toLowerCase().includes(search))
    );

    if (filteredPrompts.length === 0) {
      grid.innerHTML = "<p style='text-align:center; color: #999;'>No prompts found.</p>";
      return;
    }

    filteredPrompts.forEach((p, index) => {
      const card = document.createElement("div");
      card.className = "prompt-card";

      // Staggered animation delay per card
      const delayMs = index * 70;
      card.style.setProperty("--delay", `${delayMs}ms`);

      // Store prompt number on the card for later gray-out updates
      card.dataset.promptNumber = p.number;

      card.onclick = () => { location.href = `/prompt.html?number=${p.number}`; };
      card.innerHTML = `
        <h2>Prompt #${p.number}</h2>
        <h3>${p.title}</h3>
        ${p.description ? `<p>${p.description}</p>` : ""}
        <p class="creator">By ${p.creator}</p>
      `;
      grid.appendChild(card);
    });

    // After drawing cards, apply gray-out if we already have submissions loaded
    if (allSubmissions.length > 0) {
      updateGrayOut();
    }
  }

  async function fetchSubmissions() {
    const sheetUrl = "https://docs.google.com/spreadsheets/d/e/2PACX-1vRvhJbih4ugNXcDFt7yE5JidKzzVutkd76c3UCzTKCOB0u-ZlG3SFUgd4ZekhMjgsFWBcMnY7ukYTAE/pub?output=csv";
    const res = await fetch(sheetUrl);
    const csv = await res.text();

    const parsed = Papa.parse(csv, { header: true });
    allSubmissions = parsed.data
  .map(row => ({
    Reader: row.Reader?.trim(),
    Prompt: row.Prompt?.trim()
  }))
  .filter(row => row.Reader && row.Prompt && !isNaN(Number(row.Prompt)));

    submissionsLoaded = true;

    // Once we have data, update gray-out and progress
    updateGrayOut();
    updateProgressUI();
  }

  // ðŸ”Ž Read current reader from storage (supports old + new keys)
  function getCurrentReaderFromStorage() {
    const keys = ["rc25_current_reader", "rc2025_reader"];
    for (const key of keys) {
      try {
        const val = localStorage.getItem(key);
        if (val) return val;
      } catch (e) {
        // ignore
      }
    }
    return null;
  }

  window.addEventListener("DOMContentLoaded", () => {
    const grid = document.getElementById("promptGrid");

    // ðŸ” See if we should auto-filter on load
    const storedReader = getCurrentReaderFromStorage();
    if (storedReader && PARTICIPANTS.includes(storedReader)) {
      initialAutoFilterReader = storedReader;
      // Hide prompt cards while we fetch submissions,
      // so we don't show black â†’ then gray.
      grid.classList.add("loading");
    }

    // Show UI right away
    renderFilterButtons();

    // If no auto-filter reader, render prompts immediately (old behavior)
    if (!initialAutoFilterReader) {
      renderPrompts(window.prompts);
    }

    updateProgressUI(); // ensures the bubble has helpful text initially

    // Fetch submissions; once ready, if we have an initial auto-reader,
    // apply that filter and then reveal the grid.
    fetchSubmissions()
      .then(() => {
        if (initialAutoFilterReader) {
          activeParticipant = initialAutoFilterReader;
          renderFilterButtons();
          renderPrompts(window.prompts);
          updateProgressUI();

          // ðŸŽ‰ Confetti on auto-load if they completed all prompts
          const totalPrompts = getTotalPrompts();
          if (getCompletedCountFor(activeParticipant) >= totalPrompts) {
            launchConfetti();
          }

          grid.classList.remove("loading"); // show cards only now
          initialAutoFilterReader = null;
        }
      })
      .catch(err => {
        console.error("Error fetching submissions:", err);
        // If something breaks, at least show the prompts
        grid.classList.remove("loading");
        if (!grid.innerHTML.trim()) {
          renderPrompts(window.prompts);
        }
      });

    document.getElementById("searchInput").addEventListener("input", () => {
      renderPrompts(window.prompts);
    });

    // Intercept Ctrl+P / Cmd+P and open list.pdf instead of printing this page
    document.addEventListener("keydown", (e) => {
      const isMac = navigator.platform.toUpperCase().includes("MAC");
      const isPrintShortcut =
        (isMac && e.metaKey && !e.shiftKey && !e.altKey && e.key.toLowerCase() === "p") ||
        (!isMac && e.ctrlKey && !e.shiftKey && !e.altKey && e.key.toLowerCase() === "p");

      if (!isPrintShortcut) return;

      e.preventDefault(); // stop browser from printing the page

      const win = window.open("list.pdf", "_blank");
      if (!win) {
        alert("Please allow pop-ups to open the printable prompt list.");
        return;
      }

      win.onload = () => {
        try {
          win.focus();
          win.print();
        } catch (err) {
          console.warn("Could not auto-print PDF:", err);
        }
      };
    });
  });
</script>
  <script src="menu-config.js"></script>
  <script src="menu.js"></script>
  <script src="prompts.js"></script>
  
</body>
</html>
